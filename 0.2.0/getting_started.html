
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Getting Started &#8212; Bambi 0.4.1 documentation</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Examples" href="examples.html" />
    <link rel="prev" title="BAyesian Model-Building Interface (Bambi) in Python" href="index.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="index.html">
<p class="title">Bambi</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 current active nav-item">
 <a class="current reference internal nav-link" href="#">
  Getting Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="examples.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="api_reference.html">
  API Reference
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/bambinos/bambi" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://pypi.org/project/bambi/" rel="noopener" target="_blank" title="PyPi">
            <span><i class="fas fa-box"></i></span>
            <label class="sr-only">PyPi</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>

  

  

<nav class="bd-links" id="bd-docs-nav" aria-label="Versions navigation">
    <div class="bd-toc-item active">
        <ul class="current nav bd-sidenav">
        <li class="toctree-l1 has-children">
            <p class="caption"><span class="caption-text">Version</span></p>
            <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox">
            <label for="toctree-checkbox-1"> <i class="fas fa-chevron-down"></i></label>

            <ul>
                  
                  <li><a href="../master/index.html"> Development </a></li>
                  

                

                  
                    <li class="toctree-l2 current active"><a href="getting_started.html">0.2.0 (latest)</a></li>
                  

                

                

                  
                    <li><a href="../0.1.5/getting_started.html">0.1.5</a></li>
                  

                

            </ul>
        </li>
        </ul>
    </div>
  </nav>


            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quickstart">
   Quickstart
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#user-guide">
   User Guide
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#creating-a-model">
     Creating a model
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#data-format">
       Data format
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#model-specification">
     Model specification
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#formula-based-specification">
       Formula-based specification
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#incremental-specification">
       Incremental specification
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#notes-on-fixed-and-random-effects-in-bambi">
       Notes on fixed and random effects in Bambi
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#coding-of-categorical-variables">
       Coding of categorical variables
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#fitting-the-model">
     Fitting the model
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#building-the-model">
       Building the model
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#alternative-back-ends">
     Alternative back-ends
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#specifying-priors">
     Specifying priors
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#different-ways-of-specifying-priors">
       Different ways of specifying priors
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#a-note-on-priors-in-stan">
       A note on priors in Stan
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#mapping-priors-onto-terms">
       Mapping priors onto terms
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#generalized-linear-mixed-models">
     Generalized linear mixed models
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#families">
       Families
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#results">
     Results
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#plotting">
     Plotting
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#summarizing">
     Summarizing
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#accessing-back-end-objects">
     Accessing back-end objects
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="getting-started">
<h1>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<p>Bambi requires a working Python interpreter (3.5+). We recommend installing Python and key numerical libraries using the <a class="reference external" href="https://www.continuum.io/downloads">Anaconda Distribution</a>, which has one-click installers available on all major platforms.</p>
<p>Assuming a standard Python environment is installed on your machine (including pip), Bambi itself can be installed in one line using pip:</p>
<blockquote>
<div><p>pip install bambi</p>
</div></blockquote>
<p>Alternatively, if you want the bleeding edge version of the package, you can install from GitHub:</p>
<blockquote>
<div><p>pip install git+https://github.com/bambinos/bambi.git</p>
</div></blockquote>
<div class="section" id="quickstart">
<h2>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline">¶</a></h2>
<p>Suppose we have data for a typical within-subjects psychology experiment with 2 experimental conditions. Stimuli are nested within condition, and subjects are crossed with condition. We want to fit a model predicting reaction time (RT) from the fixed effect of condition, random intercepts for subjects, random condition slopes for students, and random intercepts for stimuli. We can fit this model and summarize its results as follows in Bambi:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bambi</span> <span class="kn">import</span> <span class="n">Model</span>

<span class="c1"># Assume we already have our data loaded</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;rt ~ condition&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;condition|subject&#39;</span><span class="p">,</span> <span class="s1">&#39;1|stimulus&#39;</span><span class="p">],</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">2</span>
<span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_trace</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="user-guide">
<h2>User Guide<a class="headerlink" href="#user-guide" title="Permalink to this headline">¶</a></h2>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#creating-a-model" id="id1">Creating a model</a></p>
<ul>
<li><p><a class="reference internal" href="#data-format" id="id2">Data format</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#model-specification" id="id3">Model specification</a></p>
<ul>
<li><p><a class="reference internal" href="#formula-based-specification" id="id4">Formula-based specification</a></p></li>
<li><p><a class="reference internal" href="#incremental-specification" id="id5">Incremental specification</a></p></li>
<li><p><a class="reference internal" href="#notes-on-fixed-and-random-effects-in-bambi" id="id6">Notes on fixed and random effects in Bambi</a></p></li>
<li><p><a class="reference internal" href="#coding-of-categorical-variables" id="id7">Coding of categorical variables</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#fitting-the-model" id="id8">Fitting the model</a></p>
<ul>
<li><p><a class="reference internal" href="#building-the-model" id="id9">Building the model</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#alternative-back-ends" id="id10">Alternative back-ends</a></p></li>
<li><p><a class="reference internal" href="#specifying-priors" id="id11">Specifying priors</a></p>
<ul>
<li><p><a class="reference internal" href="#different-ways-of-specifying-priors" id="id12">Different ways of specifying priors</a></p></li>
<li><p><a class="reference internal" href="#a-note-on-priors-in-stan" id="id13">A note on priors in Stan</a></p></li>
<li><p><a class="reference internal" href="#mapping-priors-onto-terms" id="id14">Mapping priors onto terms</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#generalized-linear-mixed-models" id="id15">Generalized linear mixed models</a></p>
<ul>
<li><p><a class="reference internal" href="#families" id="id16">Families</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#results" id="id17">Results</a></p></li>
<li><p><a class="reference internal" href="#plotting" id="id18">Plotting</a></p></li>
<li><p><a class="reference internal" href="#summarizing" id="id19">Summarizing</a></p></li>
<li><p><a class="reference internal" href="#accessing-back-end-objects" id="id20">Accessing back-end objects</a></p></li>
</ul>
</div>
<div class="section" id="creating-a-model">
<h3><a class="toc-backref" href="#id1">Creating a model</a><a class="headerlink" href="#creating-a-model" title="Permalink to this headline">¶</a></h3>
<p>Creating a new model in Bambi is simple:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bambi</span> <span class="kn">import</span> <span class="n">Model</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="c1"># Read in a tab-delimited file containing our data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="s1">&#39;my_data.txt&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># Initialize the model</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Typically, we will initialize a Bambi <code class="docutils literal notranslate"><span class="pre">Model</span></code> by passing it a pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> as the only argument. We get back a model that we can immediately start adding terms to.</p>
<div class="section" id="data-format">
<h4><a class="toc-backref" href="#id2">Data format</a><a class="headerlink" href="#data-format" title="Permalink to this headline">¶</a></h4>
<p>As with most mixed effect modeling packages, Bambi expects data in “long” format–meaning that each row should reflects a single observation at the most fine-grained level of analysis. For example, given a model where students are nested into classrooms and classrooms are nested into schools, we would want data with the following kind of structure:</p>
<table class="table">
<colgroup>
<col style="width: 23%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 17%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>student</p></th>
<th class="head"><p>gender</p></th>
<th class="head"><p>gpa</p></th>
<th class="head"><p>class</p></th>
<th class="head"><p>school</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>F</p></td>
<td><p>3.4</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>F</p></td>
<td><p>3.7</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>M</p></td>
<td><p>2.2</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>F</p></td>
<td><p>3.9</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>M</p></td>
<td><p>3.6</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>M</p></td>
<td><p>3.5</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>F</p></td>
<td><p>2.8</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>M</p></td>
<td><p>3.9</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>F</p></td>
<td><p>4.0</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="model-specification">
<h3><a class="toc-backref" href="#id3">Model specification</a><a class="headerlink" href="#model-specification" title="Permalink to this headline">¶</a></h3>
<p>Bambi provides a flexible way to specify models that makes it easy to specify the terms.</p>
<div class="section" id="formula-based-specification">
<h4><a class="toc-backref" href="#id4">Formula-based specification</a><a class="headerlink" href="#formula-based-specification" title="Permalink to this headline">¶</a></h4>
<p>Models are specified in Bambi using a formula-based syntax similar to what one might find in R packages like lme4 or nlme. A couple of examples illustrate the breadth of models that can be easily specified in Bambi:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Fixed effects only</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="s1">&#39;rt ~ attention + color&#39;</span><span class="p">)</span>

<span class="c1"># Fixed effects and random intercepts for subject</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;y ~ 0 + gender + condition*age&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1|subject&#39;</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1"># Multiple, complex random effects with both</span>
<span class="c1"># random slopes and random intercepts</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;y ~ 0 + gender&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;condition|subject&#39;</span><span class="p">,</span> <span class="s1">&#39;condition|site&#39;</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Each of the above examples specifies a full model that will immediately be fitted using either PyMC3 or Stan (more on that below).</p>
<p>Notice how, in contrast to lme4 (but similar to nlme), fixed and random effects are specified separately in Bambi. We describe the syntax and operators supported by each type of effect below; briefly, however, the fixed effects specification relies on <a class="reference external" href="(http://patsy.readthedocs.io/en/latest/overview.html">patsy</a>, and <a class="reference external" href="http://patsy.readthedocs.io/en/latest/formulas.html">hence formulas are parsed</a> almost exactly the same way <a class="reference external" href="http://patsy.readthedocs.io/en/latest/R-comparison.html">as in R</a>. Random effects terms must be specified one at a time.</p>
</div>
<div class="section" id="incremental-specification">
<h4><a class="toc-backref" href="#id5">Incremental specification</a><a class="headerlink" href="#incremental-specification" title="Permalink to this headline">¶</a></h4>
<p>Although models can be fit in one line, as above, an alternative approach that is more verbose but sometimes clearer is to enter one or more terms into the model incrementally. The <code class="docutils literal notranslate"><span class="pre">add()</span></code> method takes essentially the same arguments as the <code class="docutils literal notranslate"><span class="pre">fit()</span></code> method, but doesn’t automatically start compiling and fitting the model.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bambi</span> <span class="kn">import</span> <span class="n">Model</span><span class="p">,</span> <span class="n">Prior</span>

<span class="c1"># Initialize model</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># Continuous fixed effect (in this case, a binary indicator); will also add intercept</span>
<span class="n">automatically</span> <span class="n">unless</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">explicitly</span> <span class="n">suppressed</span><span class="o">.</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;condition&#39;</span><span class="p">)</span>

<span class="c1"># Categorical fixed effect, setting a narrow prior. We explicitly name the columns that should</span>
<span class="c1"># be interpreted as categorical.</span>
<span class="c1"># Note that if age_group is already represented as a categorical variable in the DataFrame, the</span>
<span class="c1"># categorical argument is unnecessary. But it&#39;s good practice to be explicit about what the</span>
<span class="c1"># categorical variables are, as users sometimes inadvertently pass numeric columns that are</span>
<span class="c1"># intended to be treated as categorical variables, and Bambi has no way of knowing this.</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
    <span class="s1">&#39;age_group&#39;</span><span class="p">,</span>
    <span class="n">categorical</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;age_group&#39;</span><span class="p">],</span>
    <span class="n">priors</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;age_group&#39;</span><span class="p">:</span> <span class="s1">&#39;narrow&#39;</span><span class="p">}</span>
<span class="p">)</span>

<span class="c1"># Random subject intercepts</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">random</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;subj&#39;</span><span class="p">],</span> <span class="n">categorical</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;subj&#39;</span><span class="p">])</span>

<span class="c1"># Random condition slopes distributed over subjects</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">random</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;0+condition|subj&#39;</span><span class="p">])</span>

<span class="c1"># Add outcome variable</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;y ~ 0&#39;</span><span class="p">)</span>

<span class="c1"># Fit the model and save results</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
</pre></div>
</div>
<p>As the above example illustrates, the only mandatory argument to <code class="docutils literal notranslate"><span class="pre">add</span></code> is a string giving the name of the dataset column to use for the term. If no other arguments are specified, the corresponding variable will be modeled as a fixed effect with a normally-distributed prior (a detailed explanation of how priors are handled in Bambi can be found below). The type of variable (i.e., categorical or continuous) will be determined based on the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of the column in the pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, so it’s a good idea to make sure all variables are assigned the correct <code class="docutils literal notranslate"><span class="pre">dtype</span></code> when you first read in the data. You can also force continuous variables to be treated as categorical factors by passing them as a list to the <code class="docutils literal notranslate"><span class="pre">categorical</span></code> argument (e.g., <code class="docutils literal notranslate"><span class="pre">add_term('subject</span> <span class="pre">+</span> <span class="pre">condition</span> <span class="pre">+</span> <span class="pre">extraversion',</span> <span class="pre">categorical=['subject'])</span></code>).</p>
<p>To specify that a term should be modeled as a random effect, pass the formula to the <code class="docutils literal notranslate"><span class="pre">random</span></code> argument (e.g., <code class="docutils literal notranslate"><span class="pre">random='1|subj'</span></code>). The specification of random intercepts vs. slopes is handled as in other packages, or in the full specification passed to a single <code class="docutils literal notranslate"><span class="pre">fit()</span></code> call. For example, <code class="docutils literal notranslate"><span class="pre">add(random=['1|site',</span> <span class="pre">'0+condition|subject'])</span></code> would add random condition slopes distributed over subjects (without subject intercepts), as well as random intercepts for sites.</p>
</div>
<div class="section" id="notes-on-fixed-and-random-effects-in-bambi">
<h4><a class="toc-backref" href="#id6">Notes on fixed and random effects in Bambi</a><a class="headerlink" href="#notes-on-fixed-and-random-effects-in-bambi" title="Permalink to this headline">¶</a></h4>
<p>As noted above, Bambi handles fixed and random effects separately. The fixed effects specification relies on the <a class="reference external" href="https://patsy.readthedocs.io/en/latest/overview.html">patsy</a> package, which supports nearly all of the standard formula operators handled in base R–including <code class="docutils literal notranslate"><span class="pre">:</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, etc. Unfortunately, patsy doesn’t support grouping operators, so random effects are handled separately in Bambi. All terms must be passed in as elements in a list (though each individual term can be as complex as a normal fixed effect specification). For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">random_terms</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># Random student intercepts</span>
    <span class="s1">&#39;1|student&#39;</span><span class="p">,</span>
    <span class="c1"># Random classroom intercepts</span>
    <span class="s1">&#39;1|classroom&#39;</span><span class="p">,</span>
    <span class="c1"># Random treatment slopes over schools; school intercepts will automatically added</span>
    <span class="s1">&#39;treatment|school&#39;</span><span class="p">,</span>
    <span class="c1"># A random set of subject slopes for each level of the combination of factors a and b,</span>
    <span class="c1"># with subject intercepts excluded</span>
    <span class="s1">&#39;0+a*b|subject&#39;</span>
<span class="p">]</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">random</span><span class="o">=</span><span class="n">random_terms</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="coding-of-categorical-variables">
<h4><a class="toc-backref" href="#id7">Coding of categorical variables</a><a class="headerlink" href="#coding-of-categorical-variables" title="Permalink to this headline">¶</a></h4>
<p>When a categorical fixed effect with N levels is added to a model, by default, it is coded by N-1 dummy variables (i.e., reduced-rank coding). For example, suppose we write <code class="docutils literal notranslate"><span class="pre">'y</span> <span class="pre">~</span> <span class="pre">condition</span> <span class="pre">+</span> <span class="pre">age</span> <span class="pre">+</span> <span class="pre">gender'</span></code>, where condition is a categorical variable with 4 levels, and age and gender are continuous variables. Then our model would contain an intercept term (added to the model by default, as in R), three dummy-coded variables (each contrasting the first level of <code class="docutils literal notranslate"><span class="pre">condition</span></code> with one of the subsequent levels), and continuous predictors for age and gender. Suppose, however, that we would rather use full-rank coding of conditions. If we explicitly remove the intercept –as in <code class="docutils literal notranslate"><span class="pre">'y</span> <span class="pre">~</span> <span class="pre">0</span> <span class="pre">+</span> <span class="pre">condition</span> <span class="pre">+</span> <span class="pre">age</span> <span class="pre">+</span> <span class="pre">gender'</span></code>– then we get the desired effect. Now, the intercept is no longer included, and condition will be coded using 4 dummy indicators, each one coding for the presence or absence of the respective condition without reference to the other conditions.</p>
<p>Random effects are handled in a comparable way. When adding random intercepts, coding is always full-rank (e.g., when adding random intercepts for 100 schools, one gets 100 dummy-coded indicators coding each school separately, and not 99 indicators contrasting each school with the very first one). For random slopes, coding proceeds the same way as for fixed effects. The random effects specification <code class="docutils literal notranslate"><span class="pre">['condition|subject']</span></code> would add an intercept for each subject, plus N-1 condition slopes (each coded with respect to the first, omitted, level as the referent). If we instead specify <code class="docutils literal notranslate"><span class="pre">['0+condition|subject']</span></code>, we get N condition slopes and no intercepts.</p>
</div>
</div>
<div class="section" id="fitting-the-model">
<h3><a class="toc-backref" href="#id8">Fitting the model</a><a class="headerlink" href="#fitting-the-model" title="Permalink to this headline">¶</a></h3>
<p>Once a model is fully specified, we need to run the PyMC3 or Stan sampler to generate parameter estimates. If we’re using the one-line <code class="docutils literal notranslate"><span class="pre">fit()</span></code> interface, sampling will begin right away (by default, using the PyMC3 back-end):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="s1">&#39;rt ~ condition + gender + age&#39;</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="s1">&#39;condition|subject&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above code will obtain 1,000 samples (the default value) and return them as an <code class="docutils literal notranslate"><span class="pre">InferenceData</span></code> instance (for more details, see the <a class="reference external" href="https://arviz-devs.github.io/arviz/schema/schema.html">ArviZ documentation</a>). In this case, the <cite>fit()</cite> method accepts optional keyword arguments to pass onto PyMC3’s <code class="docutils literal notranslate"><span class="pre">sample()</span></code> method, so any methods accepted by <code class="docutils literal notranslate"><span class="pre">sample()</span></code> can be specified here. We can also explicitly set the number of samples via the <code class="docutils literal notranslate"><span class="pre">samples</span></code> argument. For example, if we call <code class="docutils literal notranslate"><span class="pre">fit('y</span> <span class="pre">~</span> <span class="pre">X1',</span> <span class="pre">samples=2000,</span> <span class="pre">chains=2)</span></code>, the PyMC3 sampler will sample two chains in parallel, drawing 2,000 samples for each one. We could also specify starting parameter values, the step function to use, and so on (for full details, see the <a class="reference external" href="https://docs.pymc.io/api/inference.html#module-pymc3.sampling">PyMC3 documentation</a>).</p>
<p>Alternatively, if we’re building our model incrementally, we can specify our model in steps, and only call <code class="docutils literal notranslate"><span class="pre">fit()</span></code> once the model is complete:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;food_type&#39;</span><span class="p">,</span> <span class="n">categorical</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;food_type&#39;</span><span class="p">])</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">random</span><span class="o">=</span><span class="s1">&#39;1|subject&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="building-the-model">
<h4><a class="toc-backref" href="#id9">Building the model</a><a class="headerlink" href="#building-the-model" title="Permalink to this headline">¶</a></h4>
<p>When <code class="docutils literal notranslate"><span class="pre">fit()</span></code> is called, Bambi internally performs two separate steps. First, the model is built or compiled, via a <code class="docutils literal notranslate"><span class="pre">build()</span></code> call. During the build, the PyMC3 model is compiled by Theano, in order to optimize the underlying Theano graph and improve sampling efficiency. This process can be fairly time-consuming, depending on the size and complexity of the model. It’s possible to build the model explicitly, without beginning the sampling process, by calling <code class="docutils literal notranslate"><span class="pre">build()</span></code> directly on the model:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
    <span class="s1">&#39;rt ~ condition + gender + age&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="s1">&#39;condition|subject&#39;</span>
<span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
</pre></div>
</div>
<p>Alternatively, the same result can be achieved using the <code class="docutils literal notranslate"><span class="pre">run</span></code> argument to <code class="docutils literal notranslate"><span class="pre">fit()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;rt ~ condition + gender + age&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="s1">&#39;condition|subject&#39;</span><span class="p">,</span>
    <span class="n">run</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</pre></div>
</div>
<p>In both of the above cases, sampling won’t actually start until <code class="docutils literal notranslate"><span class="pre">fit()</span></code> is called (in the latter case, a second time). The only difference between the two above snippets is that the former will compile the model (note the explicit <code class="docutils literal notranslate"><span class="pre">build()</span></code> call) whereas the latter will not.</p>
<p>Building without sampling can be useful if we want to inspect the internal PyMC3 model before we start the (potentially long) sampling process. Once we’re satisfied, and wish to run the sampler, we can then simply call <code class="docutils literal notranslate"><span class="pre">model.fit()</span></code>, and the sampler will start running.</p>
</div>
</div>
<div class="section" id="alternative-back-ends">
<h3><a class="toc-backref" href="#id10">Alternative back-ends</a><a class="headerlink" href="#alternative-back-ends" title="Permalink to this headline">¶</a></h3>
<p>Bambi defaults to using the NUTS MCMC sampler implemented in the PyMC3 package for all model-fitting. However, Bambi also supports the NUTS sampler from Stan MCMC sampling package, via the <a class="reference external" href="https://github.com/stan-dev/pystan">PyStan</a> interface. To switch from PyMC3 to Stan, all you have to do is specify <code class="docutils literal notranslate"><span class="pre">backend='stan'</span></code> in the <code class="docutils literal notranslate"><span class="pre">fit()</span></code> call:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;rt ~ condition + gender + age&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="s1">&#39;condition|subject&#39;</span><span class="p">,</span>
    <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;stan&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>From the user’s standpoint, the change from PyMC3 to Stan (or vice versa) will usually be completely invisible. Unless we want to muck around in the internals of the backends, the API is identical no matter which back-end we’re using. This frees us up to easily compare different back-ends in terms of speed and/or estimates (assuming the sampler has converged, the two back-ends should produce virtually identical estimates for all models, but performance could theoretically differ).</p>
</div>
<div class="section" id="specifying-priors">
<h3><a class="toc-backref" href="#id11">Specifying priors</a><a class="headerlink" href="#specifying-priors" title="Permalink to this headline">¶</a></h3>
<p>Bayesian inference requires one to specify prior probability distributions that represent the analyst’s belief (in advance of seeing the data) about the likely values of the model parameters. In practice, analysts often lack sufficient information to formulate well-defined priors, and instead opt to use “weakly informative” priors that mainly serve to keep the model from exploring completely pathological parts of the parameter space (e.g., when defining a prior on the distribution of human heights, a value of 3,000 cms should be assigned a probability of exactly 0).</p>
<p>By default, Bambi will intelligently generate weakly informative priors for all model terms, by loosely scaling them to the observed data (details can be found in <a class="reference external" href="https://arxiv.org/abs/1702.01201">this article</a>. While the default priors will behave well in most typical settings, there are many cases where an analyst will want to specify their own priors–and in general, when informative priors are available, it’s a good idea to use them.</p>
<div class="section" id="different-ways-of-specifying-priors">
<h4><a class="toc-backref" href="#id12">Different ways of specifying priors</a><a class="headerlink" href="#different-ways-of-specifying-priors" title="Permalink to this headline">¶</a></h4>
<p>Bambi provides two ways to specify a custom prior. First, one can manually specify only the scale of the prior, while retaining the default distribution.
By default, Bambi sets “weakly informative” priors on all fixed and random effects. Priors are specified on a (generalized) partial correlation scale that quantifies the expected standardized contribution of each individual term to the outcome variable when controlling for other terms. The default “wide” setting sets the scale of a fixed effect prior to sqrt(1/3) = 0.577 on the partial correlation scale, which is the standard deviation of a flat prior from -1 to +1. This correlation-level scale value then gets translated to a Normal prior at the slope level, centered on 0 by default, with a correspondingly wide variance. This process results in a weakly informative (rather than non-informative) prior distribution whose width can be tuned in a simple, intuitive way. More detailed information about how the default priors work can be found in <a class="reference external" href="https://arxiv.org/abs/1702.01201">this technical paper</a>.</p>
<p>In cases where we want to keep the default prior distributions, but alter their scale, we can specify either a numeric scale value or pass the name of a predefined constant. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="c1"># Add condition to the model as a fixed effect with a very</span>
<span class="c1"># wide prior</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;condition&#39;</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="s1">&#39;superwide&#39;</span><span class="p">)</span>

<span class="c1"># Add random subject intercepts to the model, with a narrow</span>
<span class="c1"># prior on their standard deviation</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">random</span><span class="o">=</span><span class="s1">&#39;1|subject&#39;</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>Predefined named scales include “superwide” (scale = 0.8), “wide” (0.577; the default), “medium” (0.4), and “narrow” (0.2). The theoretical maximum scale value is 1.0, which specifies a distribution of partial correlations with half of the values at -1 and the other half at +1. Scale values closer to 0 are considered more “informative” and tend to induce more shrinkage in the parameter estimates.</p>
<p>The ability to specify prior scales this way is helpful, but also limited: we will sometimes find ourselves wanting to use something other than a Normal distribution to model our priors. Fortunately, Bambi is built on top of PyMC3, which means that we can seamlessly use any of the over 40 <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> classes defined in PyMC3. We can specify such priors in Bambi using the <code class="docutils literal notranslate"><span class="pre">Prior</span></code> class, which initializes with a <code class="docutils literal notranslate"><span class="pre">name</span></code> argument (which must map on exactly to the name of a valid PyMC3 <code class="docutils literal notranslate"><span class="pre">Distribution</span></code>) followed by any of the parameters accepted by the corresponding <code class="docutils literal notranslate"><span class="pre">distribution</span></code>. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bambi</span> <span class="kn">import</span> <span class="n">Prior</span>

<span class="c1"># A laplace prior with mean of 0 and scale of 10</span>
<span class="n">my_favorite_prior</span> <span class="o">=</span> <span class="n">Prior</span><span class="p">(</span><span class="s1">&#39;Laplace&#39;</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># Set the prior when adding a term to the model; more details on this below.</span>
<span class="n">priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;1|subject&#39;</span><span class="p">:</span> <span class="n">my_favorite_prior</span><span class="p">}</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;y ~ condition&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="s1">&#39;1|subject&#39;</span><span class="p">,</span>
    <span class="n">priors</span><span class="o">=</span><span class="n">priors</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Priors specified using the <code class="docutils literal notranslate"><span class="pre">Prior</span></code> class can be nested to arbitrary depths–meaning, we can set any of a given prior’s argument to point to another <code class="docutils literal notranslate"><span class="pre">Prior</span></code> instance. This is particularly useful when specifying hierarchical priors on random effects, where the individual random slopes or intercepts are constrained to share a common source distribution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">subject_sd</span> <span class="o">=</span> <span class="n">Prior</span><span class="p">(</span><span class="s1">&#39;HalfCauchy&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">subject_prior</span> <span class="o">=</span> <span class="n">Prior</span><span class="p">(</span><span class="s1">&#39;Normal&#39;</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="n">subject_sd</span><span class="p">)</span>
<span class="n">priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;1|subject&#39;</span><span class="p">:</span> <span class="n">my_favorite_prior</span><span class="p">}</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;y ~ condition&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="s1">&#39;1|subject&#39;</span><span class="p">,</span>
    <span class="n">priors</span><span class="o">=</span><span class="n">priors</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The above prior specification indicates that the individual subject intercepts are to be treated as if they are randomly sampled from the same underlying normal distribution, where the variance of that normal distribution is parameterized by a separate hyperprior (a half-cauchy with beta = 5).</p>
</div>
<div class="section" id="a-note-on-priors-in-stan">
<h4><a class="toc-backref" href="#id13">A note on priors in Stan</a><a class="headerlink" href="#a-note-on-priors-in-stan" title="Permalink to this headline">¶</a></h4>
<p>The above discussion assumes that one is using the PyMC3 back-end for model fitting. Although custom priors can be specified using the same syntax when using the Stan back-end, the variety of supported prior distributions is much more limited (the technical reason for this is that the Stan back-end requires us to explicitly add each distribution we wish to support, whereas the PyMC3 back-end is able to seamlessly and automatically use any distribution supported within PyMC3). If you plan to use uncommon distributions for your priors, we encourage you to use the PyMC3 back-end (which is also the default—so if you didn’t explicitly specify the back-end, you’re probably already using PyMC3). Note also that regardless of which back-end you use, all prior distributions use the names found in PyMC3, and not in Stan or any other package (e.g., in Stan, a half-Cauchy prior is specified as a full Cauchy prior with a lower bound of 0, but in Bambi, you would use the PyMC3 convention and pass a <code class="docutils literal notranslate"><span class="pre">'HalfCauchy'</span></code> prior).</p>
</div>
<div class="section" id="mapping-priors-onto-terms">
<h4><a class="toc-backref" href="#id14">Mapping priors onto terms</a><a class="headerlink" href="#mapping-priors-onto-terms" title="Permalink to this headline">¶</a></h4>
<p>Once we’ve defined custom priors for one or more terms, we need to map them onto those terms in our model. Bambi allows us to do this efficiently by passing a dictionary of term -&gt; prior mappings in any <code class="docutils literal notranslate"><span class="pre">fit()</span></code> or <code class="docutils literal notranslate"><span class="pre">add()</span></code> call (and also via a separate <code class="docutils literal notranslate"><span class="pre">set_priors()</span></code> method on the <code class="docutils literal notranslate"><span class="pre">Model</span></code> class). The keys of the dictionary the names of terms, and the values are the desired priors. There are also <code class="docutils literal notranslate"><span class="pre">fixed</span></code> and <code class="docutils literal notranslate"><span class="pre">random</span></code> arguments that make it easy to apply the same priors to all fixed or random effects in the model. Some examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># Example 1: set each prior by name. Note that we can set the same</span>
<span class="c1"># prior for multiple terms at once, by passing a tuple in the key.</span>
<span class="n">priors</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;X1&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span>
    <span class="s1">&#39;X2&#39;</span><span class="p">:</span> <span class="s1">&#39;normal&#39;</span><span class="p">,</span>
    <span class="p">(</span><span class="s1">&#39;X3&#39;</span><span class="p">,</span> <span class="s1">&#39;X4&#39;</span><span class="p">):</span> <span class="n">Prior</span><span class="p">(</span><span class="s1">&#39;ZeroInflatedPoisson&#39;</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">psi</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;y ~ X1 + X2&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1|X3&#39;</span><span class="p">,</span> <span class="s1">&#39;1|X4&#39;</span><span class="p">],</span>
    <span class="n">priors</span><span class="o">=</span><span class="n">priors</span>
<span class="p">)</span>

<span class="c1"># Example 2: specify priors for all fixed effects and all random</span>
<span class="c1"># effects, except for X1, which still gets its own custom prior.</span>
<span class="n">priors</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;X1&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span>
    <span class="s1">&#39;fixed&#39;</span><span class="p">:</span> <span class="n">Prior</span><span class="p">(</span><span class="s1">&#39;Normal&#39;</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="mi">100</span><span class="p">),</span>
    <span class="s1">&#39;random&#39;</span><span class="p">:</span> <span class="s1">&#39;wide&#39;</span>
<span class="p">}</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;y ~ X1 + X2&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1|X3&#39;</span><span class="p">,</span> <span class="s1">&#39;1|X4&#39;</span><span class="p">],</span>
    <span class="n">priors</span><span class="o">=</span><span class="n">priors</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Notice how this interface allows us to specify terms either by name (including passing tuples as keys in cases where we want multiple terms to share the same prior), or by term type (i.e., to set the same prior on all fixed or random effects). If we pass both named priors and fixed or random effects defaults, the former will take precedence over the latter (in the above example, the prior for <code class="docutils literal notranslate"><span class="pre">'X1'</span></code> will be <code class="docutils literal notranslate"><span class="pre">0.3</span></code>).</p>
<p>If we prefer, we can also set priors outside of the <code class="docutils literal notranslate"><span class="pre">fit()</span></code> (or <code class="docutils literal notranslate"><span class="pre">add()</span></code>) calls, using the <code class="docutils literal notranslate"><span class="pre">set_priors</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Specify model but don&#39;t build/sample just yet</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="s1">&#39;y ~ X1 + X3 + X4&#39;</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="s1">&#39;1|X2&#39;</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Specify priors—produces same result as in Example 2 above</span>
<span class="n">model</span><span class="o">.</span><span class="n">set_priors</span><span class="p">(</span>
    <span class="p">{</span><span class="s1">&#39;X1&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">},</span>
    <span class="n">fixed</span><span class="o">=</span><span class="n">Prior</span><span class="p">(</span><span class="s1">&#39;Normal&#39;</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="mi">100</span><span class="p">),</span>
    <span class="n">random</span><span class="o">=</span><span class="s1">&#39;wide&#39;</span>
<span class="p">)</span>

<span class="c1"># Now sample</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we stipulate that terms X1 and X4 will use the same normal prior, X2 will use a different normal prior with a uniform hyperprior on its standard deviation, and all other fixed effects will use the default prior with a scale of 0.5.</p>
<p>It’s important to note that explicitly setting priors by passing in <code class="docutils literal notranslate"><span class="pre">Prior</span></code> objects will disable Bambi’s default behavior of scaling priors to the data in order to ensure that they remain weakly informative. This means that if you specify your own prior, you have to be sure not only to specify the distribution you want, but also any relevant scale parameters. For example, the 0.5 in <code class="docutils literal notranslate"><span class="pre">Prior('Normal',</span> <span class="pre">mu=0,</span> <span class="pre">sd=0.5)</span></code> will be specified on the scale of the data, not the bounded partial correlation scale that Bambi uses for default priors. This means that if your outcome variable has a mean value of 10,000 and a standard deviation of, say, 1,000, you could potentially have some problems getting the model to produce reasonable estimates, since from the perspective of the data, you’re specifying an extremely strong prior.</p>
</div>
</div>
<div class="section" id="generalized-linear-mixed-models">
<h3><a class="toc-backref" href="#id15">Generalized linear mixed models</a><a class="headerlink" href="#generalized-linear-mixed-models" title="Permalink to this headline">¶</a></h3>
<p>Bambi supports the construction of mixed models with non-normal response distributions (i.e., generalized linear mixed models, or GLMMs). GLMMs are specified in the same way as LMMs, except that the user must specify the distribution to use for the response, and (optionally) the link function with which to transform the linear model prediction into the desired non-normal response. The easiest way to construct a GLMM is to simple set the <code class="docutils literal notranslate"><span class="pre">family</span></code> argument in the <code class="docutils literal notranslate"><span class="pre">fit()</span></code> call:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;graduate ~ attendance_record + GPA&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="s1">&#39;1|school&#39;</span><span class="p">,</span>
    <span class="n">family</span><span class="o">=</span><span class="s1">&#39;bernoulli&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>If no <code class="docutils literal notranslate"><span class="pre">link</span></code> argument is explicitly set (see below), the canonical link function (or an otherwise sensible default) will be used. The following table summarizes the currently available families and their associated links (the default is <code class="docutils literal notranslate"><span class="pre">gaussian</span></code>):</p>
<table class="table">
<colgroup>
<col style="width: 25%" />
<col style="width: 48%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Family name</p></th>
<th class="head"><p>Response distribution</p></th>
<th class="head"><p>Default link</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>gaussian</p></td>
<td><p>Normal</p></td>
<td><p>identity</p></td>
</tr>
<tr class="row-odd"><td><p>bernoulli</p></td>
<td><p>Bernoulli</p></td>
<td><p>logit</p></td>
</tr>
<tr class="row-even"><td><p>poisson</p></td>
<td><p>Poisson</p></td>
<td><p>log</p></td>
</tr>
</tbody>
</table>
<div class="section" id="families">
<h4><a class="toc-backref" href="#id16">Families</a><a class="headerlink" href="#families" title="Permalink to this headline">¶</a></h4>
<p>Following the convention used in many R packages, the response distribution to use for a GLMM is specified in a <code class="docutils literal notranslate"><span class="pre">Family</span></code> class that indicates how the response variable is distributed, as well as the link function transforming the linear response to a non-linear one. Although the easiest way to specify a family is by name, using one of the options listed in the table above, users can also create and use their own family, providing enormous flexibility (note, again, that custom specifications are only guaranteed to work with the PyMC3 back-end; results may be unpredictable when using Stan, as noted in <a class="reference internal" href="#a-note-on-priors-in-stan">A note on priors in Stan</a>). In the following example, we show how the built-in ‘bernoulli’ family could be constructed on-the-fly:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bambi</span> <span class="kn">import</span> <span class="n">Family</span><span class="p">,</span> <span class="n">Prior</span>
<span class="kn">import</span> <span class="nn">theano.tensor</span> <span class="k">as</span> <span class="nn">tt</span>

<span class="c1"># Specify how the Bernoulli p parameter is distributed</span>
<span class="n">prior_p</span> <span class="o">=</span> <span class="n">Prior</span><span class="p">(</span><span class="s1">&#39;Beta&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># The response variable distribution</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">Prior</span><span class="p">(</span><span class="s1">&#39;Bernoulli&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">prior_p</span><span class="p">)</span>

<span class="c1"># Set the link function. Alternatively, we could just set</span>
<span class="c1"># the link to &#39;logit&#39;, since it&#39;s already built into Bambi.</span>
<span class="c1"># Note that we could pass in our own function here; the link</span>
<span class="c1"># function doesn&#39;t have to be predefined.</span>
<span class="n">link</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">sigmoid</span>

<span class="c1"># Construct the family</span>
<span class="n">new_fam</span> <span class="o">=</span> <span class="n">Family</span><span class="p">(</span><span class="s1">&#39;bernoulli&#39;</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">link</span><span class="o">=</span><span class="n">link</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="c1"># Now it&#39;s business as usual</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;graduate ~ attendance_record + GPA&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="s1">&#39;1|school&#39;</span><span class="p">,</span>
    <span class="n">family</span><span class="o">=</span><span class="n">new_fam</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The above example produces results identical to simply setting <code class="docutils literal notranslate"><span class="pre">family='bernoulli'</span></code>.</p>
<p>One (minor) complication in specifying a custom <code class="docutils literal notranslate"><span class="pre">Family</span></code> is that the link function must be able to operate over theano tensors rather than numpy arrays, so you’ll probably need to rely on tensor operations provided in <code class="docutils literal notranslate"><span class="pre">theano.tensor</span></code> (many of which are also wrapped by PyMC3) when defining a new link.</p>
</div>
</div>
<div class="section" id="results">
<h3><a class="toc-backref" href="#id17">Results</a><a class="headerlink" href="#results" title="Permalink to this headline">¶</a></h3>
<p>When a model is fitted, it returns a <code class="docutils literal notranslate"><span class="pre">InferenceData</span></code> object containing data related to the model. This object can be passed to many functions in ArviZ to obtain numerical and visuals diagnostics and plot in general.</p>
</div>
<div class="section" id="plotting">
<h3><a class="toc-backref" href="#id18">Plotting</a><a class="headerlink" href="#plotting" title="Permalink to this headline">¶</a></h3>
<p>To visualize a plot of the posterior estimates and sample traces for all parameters, simply pass the <code class="docutils literal notranslate"><span class="pre">InferenceData</span></code> object to  the arviz function <code class="docutils literal notranslate"><span class="pre">az._plot_trace</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="s1">&#39;value ~ condition&#39;</span><span class="p">,</span>
    <span class="n">random</span><span class="o">=</span><span class="s1">&#39;1|uid&#39;</span><span class="p">,</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">1250</span><span class="p">,</span>
    <span class="n">chains</span><span class="o">=</span><span class="mi">2</span>
<span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_trace</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<p>This produces a plot like the following:</p>
<img alt="_images/sample_traceplot.png" src="_images/sample_traceplot.png" />
<p>More details on this plot are available in the <a class="reference external" href="https://arviz-devs.github.io/arviz/_modules/arviz/plots/traceplot.html">ArviZ documentation</a>.</p>
</div>
<div class="section" id="summarizing">
<h3><a class="toc-backref" href="#id19">Summarizing</a><a class="headerlink" href="#summarizing" title="Permalink to this headline">¶</a></h3>
<p>If you prefer numerical summaries of the posterior estimates, you can use the <code class="docutils literal notranslate"><span class="pre">az.summary()</span></code> function from <a class="reference external" href="https://arviz-devs.github.io/arviz/generated/arviz.summary.html#arviz.summary">ArviZ</a>  which provides a pandas DataFrame with some key summary and diagnostics info on the model parameters, such as the 94% highest posterior density intervals:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">az</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/sample_summary.png" src="_images/sample_summary.png" />
<p>If you want to view summaries or plots for specific parameters, you can pass a list of its names:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># show the names of all variables stored in the InferenceData object</span>
<span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">posterior</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

<span class="c1"># these two calls are equivalent</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_trace</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">var_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Intercept&#39;</span><span class="p">,</span> <span class="s1">&#39;condition&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>You can find detailed, worked examples of fitting Bambi models and working with the results in the example notebooks <a class="reference external" href="examples">here</a>.</p>
</div>
<div class="section" id="accessing-back-end-objects">
<h3><a class="toc-backref" href="#id20">Accessing back-end objects</a><a class="headerlink" href="#accessing-back-end-objects" title="Permalink to this headline">¶</a></h3>
<p>Bambi is just a high-level interface to other statistical packages; as such, it uses other packages as computational back-ends. Internally, Bambi stores virtually all objects generated by backends like PyMC3, making it easy for users to retrieve, inspect, and modify those objects. For example, the <code class="docutils literal notranslate"><span class="pre">Model</span></code> class created by PyMC3 (as opposed to the Bambi class of the same name) is accessible from <cite>model.backend.model</cite>. For models fitted with a PyMC3 sampler, the resulting <code class="docutils literal notranslate"><span class="pre">MultiTrace</span></code> object is stored in <code class="docutils literal notranslate"><span class="pre">model.backend.trace</span></code> (though it can also be accessed via Bambi’s <code class="docutils literal notranslate"><span class="pre">ModelResults</span></code> instance).</p>
</div>
</div>
</div>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="index.html" title="previous page">BAyesian Model-Building Interface (Bambi) in Python</a>
    <a class='right-next' id="next-link" href="examples.html" title="next page">Examples</a>

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2021, The developers of Bambi.<br/>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.0.1.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>